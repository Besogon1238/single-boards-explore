# Написание кода под RISCV-архитектуру
Я оказался в точке, в которой

* есть плата с архитектурой RISCV, под которую нужно писать программный код;
* есть ПК на архитектуре x86_64, на котором удобно писать программный код;
* есть желание сделать максимально комфортным процесс разработки и отладки кода;

Такие обстоятельства вынудили меня выяснить, что я могу сделать, чтобы облегчить себе жизнь.

Дальше возник вопрос, а собственно, как организуют работу с кодом люди, которые постоянно разрабатывают программный код, поставляемый на разные процессорные архитектуры. Я снова обратился к интернету и опыту коллег. Выяснилось, что делать это можно по-разному. Принцип, разумеется везде один:

* пишется код
* компилируется кросс-компилятором
* так или иначе переносится на целевую платформу ИЛИ целевая платформа эмулируется
* код запускается и отлаживается

## Оглавление

- [Кросс-компилятор](#cross-compiler)
- [IDE или не IDE](#ide)
- [Настройка сборки через IDE](#compile_in_IDE)
- [Запуск бинарника на плате](#test_running)
- [Сборка в изолированной среде (hasher)](#compile_in_hasher)
- [Запуск бинарника в hasher](#running_in_hasher)
- [Отладка в hasher](#debugging_in_hasher)
- [Рабочие способы отладки](#working_debugging)

<a name="cross-compiler"></a>

## Кросс-компилятор

Первое, что оказалось необходимым — **кросс-компилятор**. Кросс-компилятор — это специальный компилятор, который позволяет компилировать код для платформы, отличной от той, на которой он выполняется.

Нужен кросс-компилятор? [Их есть у Альта!](https://packages.altlinux.org/en/sisyphus/srpms/cross-toolchain-riscv64-linux-gnu/) 

Ставим:

```
# apt-get install gcc-riscv64-linux-gnu
```

Прекрасно. Кросс-компилятор — есть.

<a name="ide"></a>

## IDE или не IDE

Нужно решить, где писать программный код. Мой собственный, не самый долгий опыт разработки всегда был связан с разработкой кода с помощью IDE, не все мои коллеги разделяют такой подход. Кому то привычно быть независимым от возможностей графического отображения всего подряд и обходиться без среды разработки. Для такого подхода имеются [основания](https://habr.com/ru/articles/303554/), и, быть может, я к этому тоже приду через время. Но в данный момент мне самому, и, думаю, многим читающим мои записи привычно использовать IDE, поэтому я решил не отказывать своей привычке. 

В прочем, все оказалось не так уж и просто. О чем можно будет узнать далее.

Я решил вести разработку в привычной мне среде Eclipse. С установкой никаких проблем: [установочник доступен на официальном сайте](https://www.eclipse.org/downloads/packages/installer). В профиле установочника выбираем *Eсlipse IDE for Embedded C/C++ Developers*.

<a name="compile_in_IDE"></a>

## Настройка сборки через IDE

Поскольку я выбрал быть счас...разработчиком, который пишет код в IDE это влечет за собой необходимость эту IDE настроить. Вернее, настраивать будем не IDE, а параметры, которые будут переданы *Make*.

Make — это утилита для автоматизации сборки программного обеспечения. Она читает инструкции из файла Makefile и выполняет компиляцию, линковку и другие задачи в зависимости от изменений в исходном коде.

Первое с чем предстоит столкнуться - это заставить *make* использовать для наших манипуляции с кодом **тулчейн**, который мы установили вместе с пакетом *gcc-riscv64-linux-gnu*.

**Тулчейн (Toolchain)** — это набор инструментов (утилит, компиляторов, библиотек), которые используются для разработки и сборки программного обеспечения под определенную платформу или архитектуру.

Cоздаем пустой проект C/C++ > C Managed Build > Hello World RISC-V C++ Project > RISC-V Cross GCC > Toolchain name = что_бы_то_ни_было & toolchain path = /usr/bin.

Можно попробовать собрать проект, и разумеется, ничего не выйдет поскольку *make* понятия не имеет, что такое *что_бы_то_ни_было*, которое мы выбрали в качестве имени тулчейна. Идем в Properties проекта > C/C++ Build > Settings > Toolchains. Вот здесь мы и настроим наш уже установленный в папку */usr/bin* тулчейн. Имя тулчейна можно оставить любое, архитектура RISCV, префикс устанавливаем *riscv64-linux-gnu-*, компиляторы gcc и g++. Затем проверяем, что toolchain path *usr/bin*, и применяем настройки. Теперь Make будет знать, где лежат и как называются все компоненты установленного тулчейна. Пробуем построить проект. Все должно получиться.

<a name="test_running"></a>

## Тестирование запуска бинарника на плате

Итак, теперь, наше *Hello World* приложение собрано для интересующей нас архитектуры. Можно попробовать ее исполнить, к чему и приступим.

Для этого авторизуемся в root на плате и настроим сеть

```
# nmcli dev show # узнаем как называется wifi-интерфейс
# nmcli dev wifi # узнаем доступные wifi сети
# nmcli dev wifi connect "название_сети" password "пароль_сети"

# ping ya.ru # проверим, что у появился DNS и выход в интернет

# ip a # узнаем текущий айпишник платы

```

<a name="ssh"></a>

Если плата находиться в одной сети с ПК, значит, можно попробовать подклюиться по ssh. Если до этого момента у вас есть только учетная запись root, необходимов в /etc/openssh/sshd_config расскомментировать параметр PermitRootLogin и поставить после его обяъявления значение "yes".

```
# apt-get install nano  # поставим редактор(если его не было)
# nano /etc/openssh/sshd_config # исправляем параметр(если надо)
# systemctl restart sshd # перезапустим, sshd
# systemctl status sshd # проверим, работает ли ssh
```

Если все хорошо, то можно передать скомпилированный бинарник на целевое устройство и там его выполнить

```
# scp /путь/до/бинарника имя_пользователя@айпи.нашей.riscv.платы:/куда/положить # пользователь по умолчанию root, пароль altlinux
```

Остается выполнить бинарник и порадоваться.

<a name="compile_in_hasher"></a>

## Сборка в изолированный среде

Прекрасно! Но у меня сразу созрел вопрос. А как мне вести разработку дальше? Ведь, если писать не *Hello World* приложение, а что то чуть более серьезное, то появиться необходимость постоянно собирать программу вместе с различными заголовочными файлами, которые не входят в стандартную библиотеку. Кроме того, чтобы проверить работу приложения каждый раз нужно будет руками или каким то скриптом пересылать бинарник на плату и там его выполнять. Мне захотелось найти путь, по которому от этих неудобств можно избавиться.

Я спросил совета у опытного человека, который дал мне ценную идею и способ ее реализации. И, скажу откровенно, меня вся эта схема впечатлила. Не догадывался, что такое возможно. Данный способ обусловлен использованием связки двух технологий: [hasher](https://www.altlinux.org/Hasher) и [QEMU](https://ru.wikipedia.org/wiki/QEMU).

Стоит внести краткий вводные. 
*QEMU* – это эмулятор, который может выполнять код, предназначенный для одной архитектуры процессора, на другой. *qemu-user-static* – версия *QEMU*, работающая без полной эмуляции всей системы, обеспечивающая только исполнение бинарников.

*hasher* — это инструмент безопасной и воспроизводимой сборки пакетов. Инструмент спроектирован так, чтобы не допускать влияния собираемого пакета на хост-систему, а также взаимного влияния собирающихся пакетов.

В этой схеме qemu-user-static будет применяться по прямому назначению для запуска собранных бинарников, а hasher будет обеспечивать  изолированную среду, в которой будут тестироваться собранные пакеты, симулируя тем самым файловую систему реальной железки. Такая схема позволить запускать собираемые бинарники без их пересылки на реальное устройство и не беспокоится о коллизиях, которые могут возникнуть в рантайме приложения.

Отдельно отмечу, поскольку один из читателей дневника сакцентировал внимание на этом моменте, что *hasher* во всей этой машинерии нужен, чтобы обеспечить среду приближенную к реализации и исполнению на реальной железяке с соответствующей *чистой* файловой системой, пакетами и архитектурой.

Если описать кратко перечень необходимых действий, то требуется следующая последовательность:

* Установить пакет qemu-user-static-binfmt-riscv
* Установить hasher и настроить его
* Поставить в hasher то, что нужно для сборки программы
* Передать chroot hasher мейку в качестве sysroot для кросс-компилятора
* Проверить результат работы в хэшере

Начнем с самого простого :)

```
# apt-get install qemu-user-static-binfmt-riscv
```

Теперь установим и настроим hasher.Предлагаю обратиться к [руководству по hasher](https://www.altlinux.org/Hasher/Руководство). По данному руководству необходимо выполнить некоторые конкретные пункты:

* Установка
* Добавление пользователя

После этого

```
$ mkdir ~/hasher # создаем директорию для сборочной среды(можно выбрать любое место, но на tmpfs будет быстрее см.руководство)
```

Далее создаю в папке ~/apt(или любой другой) файлы apt.conf.riscv64-pve и sources.list.riscv-pve. Данная конфигурация укажет хэшеру, откуда брать пакеты для установку в среду. Приведу содержимое файлов.

apt.conf.riscv64-pve
```
Dir::Etc::main "/dev/null";
Dir::Etc::parts "/var/empty";
Dir::Etc::SourceParts "/var/empty";
Dir::Etc::sourcelist "/ваш/хомяк/apt/sources.list.riscv-pve";

RPM::Ignore { "vim-plugin-vimruby"; };
```

sources.list.riscv-pve

```
rpm [sisyphus-riscv64] http://ftp.altlinux.org/pub/distributions/ALTLinux/ports/riscv64 >

rpm [sisyphus-riscv64] http://ftp.altlinux.org/pub/distributions/ALTLinux/ports/riscv64 >
```

После чего создаем окружение явно с указанием архитектуры, пути к конфигу для пакетного менеджера

```
$ hsh --init --target riscv64 --apt-conf ~/hasher/apt/riscv64-pve.conf ~/папка/с/вашим/окружением/hsh-rv64
```

Далее, если нам необходим или будет необходим какой то пакет внутри хэшера можно воспользоваться следующей командой, чтобы поставить в hasher нужное:

```
$ hsh-install ~/папка/с/вашим/окружением/hsh-rv64 название-необходимого-пакета
```

Кроме того, теперь у нас появилась возможность войти в окружение хэшер, и например выполнить в нем какой то скрипт или бинарник.

```
$ hsh-shell ~/папка/с/вашим/окружением/hsh-rv64
```

Фуууух. Дело осталось за малым. Нужно научить мейк передавать chroot в качестве sysroot кросс-компилятору и указывать компилятору откуда брать библиотеки. 

Решаем вопрос с библиотеками:

Перейдем в Настройки проекта > C/C++ Build > Settings > Tool Settings > GNU RISC-V CROSS C Compiler > Includes

```
Include paths = /путь/до/чрута/хэшера/usr/include
```

Перейдем в Настройки проекта > C/C++ Build > Settings > Tool Settings > GNU RISC-V CROSS C Linker > Libraries

```
Library search path = /путь/до/чрута/хэшера/usr/lib
```

Укажем chroot хэшера в качестве sysroot: 

Перейдем в Настройки проекта > C/C++ Build > Settings > Tool Settings > GNU RISC-V CROSS C Compiler > Command

```
Command=${cross_prefix}${cross_c} --sysroot ~/hasher/hsh-rv64/chroot ${cross_suffix}
```

<a name="running_in_hasher"></a>

## Исполнение программы в изолированной среде 

Для того, чтобы что-то выполнить в hasher, это что-то нужно туда поместить. Я решил поступить в лоб, и после компиляции бинарника копировать его в корень chroot хэшера, указав это в параметре make, в настройка сборки.

```
Post-build steps Command=cp ~/eclipse-workspace/путь/к/созданному/бинарнику.elf ~/путь/к/chroot
```
Пора настроить запуск нашего бинарника: в Run Configuration проекта указываем в параметре C/C++ Application 

```
/абсолютный/путь/в/chroot/бинарник.elf
```
 
На кураже совсем забыл указать, а зачем во всей это схеме нужен был пакет qemu-user-static-binfmt-riscv. Спасибо sorochaniv@basealt.ru за внимание к этому подразделу. Данный пакет позволяет запускать бинарники, скомпилированные под другую архитектуру. 

Только чтобы все заработало обязательно нужно во вкладке Environment указать значение переменной окружения. Спасибо за подсказку от *опытного коллеги*.

```
QEMU_LD_PREFIX=/абсолютный/путь/к/chroot
```

Данная переменная укажет,где находится динамический загрузчик (в нашем случае '/lib64/ld-linux-riscv64-lp64d.so.1'), который загружает и связывает динамические библиотеки при запуске программы.

Если все манипуляции были выполнены программу можно будет выполнить в hasher с помощью hsh-run, или зайдя в его окружение с помощью hsh-shell, или прямо из IDE, как на картинке.
![Запуск в IDE](/pictures/Запуск%20в%20IDE.png)



Теперь я почти счастлив. Была бы еще отладка...но с этим все несколько сложнее и надо разбираться :)

<a name="debugging_in_hasher"></a>

## Отладка в изолированный среде

А она де-факто для нашего случая просто невозможна. Существует возможность [отлаживать что либо в hasher под x86_64](https://www.altlinux.org/Hasher/gdb) архитектуру. Но использовать такой способ для целевой архитектуры отличной от хостовой не получится. 

Если предпринять попытку запустить gdb в hasher то непременно попадешь в проблему отсуствия возможности использовать [ptrace вызовы](https://habr.com/ru/companies/otus/articles/898448/).

Получается, что в изолированной среде отлаживать, что либо получится только printf-отладкой, что меня конечно не устраивает. Этот метод зачастую неудобен и не отражает того, что происходит в полной мере.

<a name="working_debugging"></a>

## Рабочие методы отладки

Исходя из выводов предыдущего раздела, по существу, есть два варианта для отладки программы под наши riscv64 платы, если она понадобится:

* Отлаживать программу, подключаясь к плате и работая с консольным интерфейсом gdb
* Отладка с использованием ssh плагина для VSCodium

Рассмотрю подробнее про второй способ, о котором я узнал от опытного товарища, и который показался мне более удобным.

### Подключение к плате с помощью плагина Remote-SSH

Начнем с первого варианта, о котором мне рассказал мой более опытный товарищ. Существует такой плагин для редактора исходного VS Code, который называется "Open Remote - SSH". Он, используя протокол ssh, позволяет писать, компилировать и отлаживать код на удаленной машине, работая на основной(разумеется, с издержками). Я **обращаю внимание**, что поддержка riscv64 есть только в неофициальном плагине для **VSCodium**. И с ним есть небольшая загвоздка, о который расскажу далее.

Все, что требуется для работы с этим плагином уже описано [выше](#ssh). Если вы можете подключиться к плате по ssh и выполнять команды из консоли. Значит, на бумаге, вы готовы.

```
# apt-get install codium # ставим редактор кода
```

Устанавливаем расширение для среды разработки, и жмем комбинацию *Ctrl + Shift + P*. В появившемся окне выбираем *Remote-SSH: Connect to Host*. Далее, все идет по стандартному сценарию подключения по ssh с использованием пароля: вводим цель подключения в формате имя_пользователя@ip_адрес, после чего вводим пароль. Вуаля! После небольшого ожидания будет получен доступ к файлам выбранного пользователя(в моем случае это root). Остается только настроить среду.

Все бы хорошо, но есть парочка НО.

* Перед попыткой подключения стоит убедиться, что на целевой плате установлен gcc и его библиотеки. 
* Проблема с работой для [образа](https://ftp.altlinux.org/pub/people/iv/images/riscv64/regular-sunxi-riscv64/), который был предложен к использованию

Суть проблемы следующая. При успешном подключение по ssh по пути /$HOMEDIR/.vscodium-server/bin/ устанавливается баш скрипт, который выкачивает [отсюда](https://github.com/VSCodium/vscodium/releases/download/1.99.32562/vscodium-reh-linux-riscv64-1.99.32562.tar.gz)  *vscode-server* и разрешает его запускать. Но зачастую на каком то моменте все обламывается и подключения не происходит, хотя архив загружен и распакован в нужное место.

Через некоторое время я выяснил, что, по видимому, вся проблема заключается в том, что при подключении плагин загружает переменные окружения из shell удаленной машины и просто не дожидается ответа. За время на ответ отвечает параметр shellEnvironmentResolutionTimeout* из настроек VSCodium. Его увеличение позволяет решить проблему.

P.S. Иногда все равно требуется 2 попытки подключения...

После этого отлаживать код на Lichee RV и Mango PI станет возможным, но с кокретными ограничениями в производительности. Скомпилировать и запустить Hello-World программу можно приблизительно за 10~ секунд :)

P.S Чтобы начать работать на удаленной машине в открытом новом окне редактора идем в *Главное меню* > *File* > *Open Folder*.

### Компиляция, запуск и отладка C/C++ проектов на удаленной машине

На данном этапе каждому предоставлен полный карт-бланш на настройку окружения разработки и редактора кода. Я поделюсь собственным наиболее удобным для себя сетапом. Прежде чем перейти к его описанию напомню, что на этом шаге на плате уже должен быть установлен gcc, а также необходимо установить отладчик gdb из репозитория.

После того, как вы вошли по ssh на плату и выбрали место для своего нового проекта, вам нужно установить два расширения для VSCodium сервера на плате: *С/C++ Runner* упрощающий сборку проектов без ручного конфигурирования конфига [tasks.json](https://code.visualstudio.com/docs/debugtest/tasks) и *CDT GDB Debugger* для интеграции с gdb на плате.

Протестировать, как работает компиляция, запуск и отладка на плате с предложенными мной расширениями VSCodium можно на самом простом примере. Создадим папку проекта, в ней создадим каталог *src* и внутри создадим файл .cpp:

```
#include <iostream>
using namespace std;

int main() {

    int tmp = 0;

    cout << "Hello, VS Code C++!" << endl;
    return 0;
}
```

После установки расширения *С/C++ Runner* в нижней панели редактора появится желтая надпись с предложением выбрать папку проекта. В ней достаточно указать путь к каталогу *src*. Вообще, что я тут понаписал можно не читать и более подробно почитать понятную [документацию к расширению](https://marketplace.visualstudio.com/items?itemName=franneck94.c-cpp-runner).

![alt text](/pictures/extension_panel.png)

Теперь по нажатию кнопки *Start compilation* в папке проекта должна появиться папка *.vscode*, в которой будут содержаться автоматически сгенерированные .json файлы настройки компиляции и запуска программы(их можно редактировать и руками), а в каталоге *src* появится папка *build* с скомпилированным объектным файлом и бинарником(по умолчанию будет называться outDebug или outRelease в зависимости от выбранного в нижней панели режима компиляции).

Запуск бинарника должен пройти без проблем. А вот авитоматически сгенерированные настройки для отладки, в моем случае, пришлось поднастроить.

По умолчанию, для отладки расширение использует конфигурацию ![alt text](/pictures/debug_conf_default.png)

Жмем на *кнопку выбора конфигурации для отладки* > *Add configuration* > в раскрывшемся контекстном меню *GDB CDT Local Debugging*. Получим такую новую конфигурацию в файле */.vscode/launch.json*:

```
{
  "type": "gdb",
  "request": "launch",
  "name": "Name here",
  "program": "${workspaceFolder}/${command:askProgramPath}"
}
```

Немного видоизменим его:

```
{
  "type": "gdb",
  "request": "launch",
  "name": "Имя_конфигурации_которое_вам_нравится",
  "program": "${workspaceFolder}/путь/до/сгенерированного/бинарника"
}
```

Готово! Теперь можно выбрать конфигурацию с заданным именем, поставить точки останова или просто повыполнять программу пошагово, чтобы проверить, как работает отладчик.

Хотел было я на этом и закончить со своим сетапом, но не смог. Я понял, что мне лично хотелось бы обеспечить себе подсветку синтаксиса, возможность переходить к определению и объявлению функций, переменных и тд.

Поэтому мне пришлось обеспечить себя работой еще одного популярного расширения для VSCodium [*Clangd*](https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd) собственно представлющую собой обертку для работы с [clangd](https://clangd.llvm.org/).

Для начала, поставим из репозитория пакета clang и clangd. Далее, устанавливаем на удаленную машину расширение, указываем параметр **clangd.path = /usr/bin/clangd**.

Параметр можно найти по пути *File > Preferences > Settings > Remote [SSH: ip.адрес.нашей.платы ]> Extensions > clangd*.

Далее необходимо вызвав *Ctrl+alt+p* вызвать функцию активации расширения, и подождать пока расширение свяжется с Clangd-сервером и проиндексирует проект.

Вот теперь можно с комфортом можно делать все и сразу на удаленной машине!

P.S. Утановив расширение VSCodium для Python также можно работать и на нем, но не дебажить :(.
