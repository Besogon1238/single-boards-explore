# Подробнее об образах ОС

По мере погружения в разработку под одноплатники у меня начал нарастать интерес по устройству механизма развертывания операционной системы на плате.

Я уже демонстрировал в подразделе ["Установка образа операционной системы"](#install) самый простой вариант записи образа на носитель.

Там я использовал уже подготовленный для lichee_rv образ с кастомным ядром 6.1.0-d1-un-alt. Запуск с данным образом позволяет использовать всю необходимую перефирию: сеть и графику(хотя ее этому одноплатнику ой как тяжело тащить).

Но вообще, существуют и [регулярные сборки для riscv64](https://www.altlinux.org/Regular/riscv64) с более актуальным ядром. Другое дело, что интересующий нас SoC поддерживает регулярные сборки только теоретически. На деле, запись такого образа на lichee_rv позволит работать в системе, но без графики и сети, что ну..неудобно.

Кстати говоря, в статьях про [регулярные сборки](https://www.altlinux.org/Regular) и [регулярные сборки для riscv](https://www.altlinux.org/Ports/riscv64) упоминается инструмент [alt-rootfs-installer](https://www.altlinux.org/Write/rootfs). Использование данного инструмента позволяет легко запустить на плате Alt Linux с различными графическими оболочками. Для этого достаточно иметь архив с корневой файловой системой, а загрузчик и ядро, которое **запуститься** на нужном вам поддерживаемом устройстве утилита определит и поставит сама.

## Оглавление
- [Постановка задачи](#take_task)
- [Сборка ядра](#take_task)
- [Device Tree](#device_tree)
- [Загрузчик](#bootloader)
- [rootfs](#rootfs)
- [Подготовка образа](#preparing_image)


<a name="take_task"></a>

## Постановка задачи

Но все таки, мне хотелось бы понять и разобраться в технологии создания образа глубже. Собственно поделюсь тем, что узнал на данный момент.

Итак, что же нам нужно, чтобы получить образ с *нужным нам ядром, файловой системой и перефирией*:

 - архив с корневой файловой системой(rootfs)
 - исходники ядра(kernel source)
 - собранный u-boot
 - make и прочие сборочные зависимости
 - кросс-компилятор

 Теперь заново уконкретизирую задачу, чтобы было проще выстроить повествование. Я(мы!) хочу собрать образ **ALT Linux** для платы **Lichee RV** с более-менее свежим ядром, работающим wifi-модулем 

Отлично, возьмем [кросс-компилятор из репозитория](#cross-compiler), [регулярную сборку rootfs](https://www.altlinux.org/Regular/riscv64), заботливо собранный добрыми людьми, [готовый для работы u-boot](https://packages.altlinux.org/ru/sisyphus_riscv64/srpms/u-boot-sunxi-riscv/)(а иначе самому бы пришлось собирать!), [исходники ядра 6.16](https://packages.altlinux.org/ru/sisyphus/srpms/kernel-source-6.16/).


В случае необходимости установить ОС «Альт» на устройство без реализованных BIOS или EFI требуется дополнительный загрузчик. В основном для этой цели используется u-boot. Он берет на себя первоначальную инициализацию необходимых для загрузки устройств, загружает в память ядро linux, возможные initrd и dtb и передает управление ядру. Эта составляющая у нас уже есть. Останется только записать его на флеш-карту. Но об этом позже.

<a name="kernel compilation"></a>

## Сборка ядра

Далее, наверное, самая интригующая часть: сборка ядра. 

Сборка ядра Linux из исходных кодов — это процесс компиляции и компоновки исходного кода ядра в исполняемые файлы (ядро и загружаемые модули) на основе предоставленной вами конфигурации.

Предварительно, установим необходимые пакеты:

```
# apt-get install wget build-essential bc flex bison u-boot-tool ncurses-devel openssl libssl-devel dtc
```

Архив с исходным кодом получим в папке */usr/src/kernel/sources/kernel-source-6.16.tar*, установив соответствующий пакет.

Для этого переключимся на репозиторий [Sisyphus](https://www.altlinux.org/%D0%A7%D1%82%D0%BE_%D1%82%D0%B0%D0%BA%D0%BE%D0%B5_Sisyphus%3F) и выкачаем из него архивы с пакетами.
```
# apt-repo rm all

# apt-repo set sisyphus

# apt-get update
```
А затем установим нужный пакет

```
# apt-get install kernel-source-6.16
```

Распакуем в удобное место архив и перейдем в его корневую папку.

Далее, нам будет необходимо сконфигрировать файл .config, который собирает в себя все возможные параметры для сборки ядра.

Существует несколько способов создания такого файла. Воспользуемся классическим интерфейсом для make. Выполним
```
$ make menuconfig
```

Откроется интерактивный интерфейс для тонкой настройки, который позволяет представить древовидную структуру всех опций ядра (драйверы устройств, поддержка файловых систем, сетевые функции и т.д.) и выбирать нужные.

В menuconfig все навигируется стрелками. Выбор опций осуществляется с помощью Enter, включение (Y), выключение (N), установка опции как модуль (M) осуществляется с помощью соответствующих клавиш. Кроме того может пригодиться поиск нужных опций конфигурации и их зависимостей (/).

По завершении выбора нужных настроек все сохраняется в файл конфигурации .config.

Приведу пример включения параметра PREEMPT_RT, отвечающего за включение в ядро модуля поддержки мягкого реального времени.

Для начала, можно в файл .config включить стандартную конфигурацию ядра, которая заполнит все параметры и теоретически позволяет запуститься ядру на любом устройстве указанной архитектуры. Сделать это можно так. 

```
$ make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- defconfig
```
Эта команда готовит исходный код ядра Linux к сборке для архитектуры RISC-V, используя кросс-компиляцию. Рассмотрим подробнее, что мы передали в качестве аргументов и что будет выполнено в результате.

**ARCH=riscv** указывает целевую архитектуру процессора, для которой мы собираем ядро. Исходный код ядра Linux поддерживает десятки архитектур (x86_64, arm, arm64, powerpc, riscv и т.д.). Код, специфичный для каждой архитектуры, лежит в разных поддиректориях (например, arch/x86/, arch/arm/, arch/riscv/). Переменная ARCH говорит утилите make и системе сборки, к какой из этих директорий обращаться для поиска правильных исходников, конфигураций и правил сборки.

В данном случае мы говорим системе — "собирай не для моей родной архитектуры (скорее всего, x86_64), а для RISC-V".

**CROSS_COMPILE=riscv64-linux-gnu-** задает префикс для набора инструментов компилятора (toolchain), который используется для кросс-компиляции.

Для этого нужен специальный компилятор — кросс-компилятор. Его бинарные файлы обычно имеют префикс, указывающий на целевую архитектуру.

**riscv64-linux-gnu-** — это и есть тот самый префикс. Система сборки будет вызывать не просто gcc, а riscv64-linux-gnu-gcc; не ld, а riscv64-linux-gnu-ld и так далее. Об установке нужного кросс-компилятора прочитать можно [здесь](#cross-compiler).

**defconfig** — это цель (target) для make. Она генерирует базовый конфигурационный файл (.config) для выбранной архитектуры.

В директории arch/<arch>/configs/ (в нашем случае arch/riscv/configs/) лежат несколько заранее подготовленных конфигурационных файлов. defconfig — это обычно конфигурация по умолчанию для данной архитектуры. Она включает все необходимые опции для базовой работоспособности ядра на большинстве устройств с этой архитектурой, но без специфичных драйверов для какого-то конкретного железа.

Выполнение этой цели скопирует конфиг из arch/riscv/configs/defconfig в корневую директорию с исходным кодом ядра и сохранит его как файл .config, что и станет отправной точкой для нашей настройки.

Произведем донастройку получившейся конфигурации.

```
$ make ARCH=riscv menuconfig
```

P.S указание архитектуры здесь необходимо для того, чтобы система сборки обратилась к директории arch/riscv/ для получения всех архитектурно-зависимых настроек, списков плат и драйверов.

Итак, мы в графическом меню, и нам необходимо включить параметр *PREEMPT_RT* для того, чтобы добавить соответствующий модуль ядра в конфигурацию. Жмем (/) и пишем название параметра в появившееся поле ввода.

![alt text](/pictures/search_in_menuconfig.png)

Получив такой вывод можно сделать вывод о том,где в дереве расположен параметр и какие параметры с какими значениями нужно установить для возможности включения целевого параметра. В нашем случае необходимо чтобы параметр *EXPERT* был включен(он выключен), параметр *ARCH_SUPPORTS_RT* был включен(уже), а параметр *COMPILE_TEST* был отключен(тоже уже так).

Включив параметр *EXPERT* и найдя по указанному пути расположение параметра *PREEMPT_RT* мы получим желаемое.

Аналогично для того, чтобы обеспечить работу wifi-модуля Realtek 8723DS нужно будет найти и включить параметры RTW88_RTL8723DS. Кроме того, понадобиться указать в конфигурации, что сборка ведеся для платы с процессором Allwinner D1 от компании Sunxi, и включить поддержку различных аппаратных микросхем для нашей платы от компании Lichee RV.

*На момент публикации коммита (10.09.2025) у меня не вышло обеспечить работу wifi на плате. Но это, видимо связанно с неправильным device-tree, о чем расскажу подробнее позже.*

На данный момент я создал [репозиторий](https://github.com/Besogon1238/Researches_for_Lichee_RV), в котором складываю **все, что пригодилось мне или может пригодиться для сборки образа под Lichee RV**. Там будет все, кроме содержимого директории сборки ядра(она же первоначально директория с исходниками). В частности, сейчас там можно найти уже готовый конфиг для сборки ядра и образы самих ядер.

По завершении указанных действий, можно произвести попытку запуска сборки командой.

```
$ make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- -j$(nproc)
```

Возможно, при этом make через CLI начнет задавать множество вопросов о конфигурации параметров, значение которых не было задано. Для этого предварительно нужно поменять конфиг, вызвав make с командой *olddefconfig*. В таком случае в наш конфиг для всех незаполненных параметров будут применены значения по умолчанию, как в defconfig.

Так что обобщенный порядок действий для нашего случая можно описать так:

```
$ cd ~/директория/сборки/

# загрузили в .config конфиг по умолчанию
$ make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- defconfig

# сделали специфичные изменения
$ make ARCH=riscv menuconfig

# (опционально) заполнили активные, но не установленные параметры значениями по умолчанию

$ make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- olddefconfig

# запустили сборку ядра

$ make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- -j$(nproc)
```

После окончания сборки по пути *arch/riscv/boot/* можно будет найти бинарный файл готового ядра, а также его сжатый вариант с расширеним .gz. Кроме того в других подкаталогах будут сгенерированы внешние модули ядра.

<a name="device_tree"></a>

## Device Tree

После завершения сборки, в зависимости от того, поддержка каких SoC была выбраны в соответствующем разделе дерева параметров в директории сборки по пути *arch/архитектура/boot/dts/производитель* из файлов .dts будут скомпилированы файлы .dtb.

Статья на altlinux.org [прилагается](https://www.altlinux.org/Device_Tree).

Введу лишь несколько определений.

**Device Tree (DТ)** — это структура данных, которая описывает "железо" системы  для операционной системы. Позволяет одному ядру ОС работать на разных устройствах без перекомпиляции.

**DTS (Device Tree Source)** — исходный, человекочитаемый текстовый файл с описанием устройства (.dts или .dtsi для include-файлов).

**DTB (Device Tree Blob)** — бинарный, скомпилированный файл (.dtb), который загружается ядром ОС.

Основной источник(ресурс) dts — исходники ядра Linux и репозитории разработчиков железа. Файлы .dts лежат по пути arch/архитектура/boot/dts/производитель/ (например, arch/riscv/boot/dts/allwinner).

**Как такое написать самому?**
Если вдруг в наличии подходящего .dts файла нету, то нужно будет найти и изучить Datasheet для вашего SoC. Это главный источник информации об адресах периферии и их регистрах.

Как вариант, который приходит в голову - найти .dts файл для максимально похожего устройства в исходниках ядра и с ним уже что то придумывать. Я попробовал — и пока забросил это дело...ведь все что нужно для нашего случая уже есть.

Поскольку у меня в распоряжении плата Lichee RV **Dock**, и в исходниках ядра есть device tree от производителя, проблем с написанием исходного файла нет.

<a name="bootloader"></a>


## Загрузчик

...

<a name="rootfs"></a>


## rootfs

За примерами установки rootfs из архива на SD-карту или преобразования архива в готовый img-образ для конкретной платы с помощью alt-rootfs-installer предлагаю обратиться по ссылкам выше.         

<a name="preparing_image"></a>

## Подготовка образа


...
