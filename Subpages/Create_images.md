# Подготовка образа

## Оглавление
- [Разбивка SD-карты](#sd_card_prep)
- [Запись компонентов образа](#write_image_components)

<a name="sd_card_prep"></a>

## Разбивка SD-карты

Теперь можно описать процесс записи образа на sd-карту, заодно перечислив все необходимые компоненты.

Итак, начнем с того, что предварительно нам нужно будет изменить разбивку sd-карты, если такая присутствует.

Для этого предварительно затрем начало SD-карты нулями, при чем с запасом, чтобы гарантированно уничтожить таблицу разделов(10 МБ для этого вполне достаточно).

```
$ sudo dd if=/dev/zero of=/dev/sdX bs=1M count=10
```

Продолжим. Запустим утилиту fdisk и зададим разбиение на 2 раздела. После чего, я поясню наглядно, чего мы тем самым добились.

```
$ sudo fdisk /dev/sdX
```

```
o               # создаем новую DOS таблицу разделов
n               # новый раздел
p               # primary
1               # номер раздела
2048            # начальный сектор
+100M           # размер 100MB
n               # новый раздел
p               # primary
2               # номер раздела
[Enter]         # начать сразу после первого раздела
+29.6G          # все оставшееся пространство
w               # записать изменения и выйти
```

Далее нужно отформатировать созданные разделы в файловую систему(vfat) и файловую системы ext4 с соответсвующими метками. Выбор файловых систем обусловлен тем, что u-boot "из коробки" работает с файловой системой vfat, а ext4 просто достаточно надежная и подходит для размещения на нем rootfs.
```
$ sudo mkfs.vfat -n BOOT /dev/sdX1

$ sudo mkfs.ext4 -L ROOTFS /dev/sdX2
```

Готово!

Можно проверить результат

```
$ sudo fdisk -l /dev/sdX
```
<a name="write_image_components"></a>

## Запись компонентов образа

Сделаю небольшой спойлер и представлю схематично, как будет выглядеть финальное пространство sd-карточки. В моем случае, она на 32 Гб. 

![alt text](/pictures/разбивка_карты.png)

Теперь нужно пояснить, что и куда будет записано. 

### Запись u-boot

Для начала, запишем u-boot в начало карты командой

```
$ sudo dd if=/путь/до/загрузчика/lichee rv dock/u-boot-sunxi-with-spl.bin of=/dev/sdX bs=1k seek=8
```

Таким образом, загрузчик будет записан до начала таблицы разделов, и первоначальный загрузчик платы сможет передать ему управление. Для этого мы специально пропустили с помощью параметра *seek* 8 килобайт памяти от начала пространства карточки. Синим на картинке изображены пропущенные 8K, а красным пространство занимаемое загрузчиком.

В картинке **есть немного лукавства**, ведь неспроста сначала стиралась а потом заново составлялась **таблица разделов**, которая очевидно присутствует где то на sd-карте. И это действительно так. Между пространством под загрузчик(красный блок) и пространством загрузочного раздела(желтый блок) есть небольшое пространство, в котором и находиться таблица разделов.

### Раздел BOOT

Теперь, нам необходимо заполнить всем необходимым раздел BOOT

По-хорошему, стоит здесь рассказать, как получить ядро, поддерживающее нужную перефирию и как указать в конфиге сборки сборку нужного dtb, но пока можно ограничиться уже собранным мной ядром и dtb файлом из вот [этого репозитория](https://github.com/Besogon1238/Researches_for_Lichee_RV).

Склонируем репозиторий, куда удобно
```
$ git clone https://github.com/Besogon1238/Researches_for_Lichee_RV
```

Для начала, положим на BOOT самое главное — ядро(или сжатое ядро .gz) с именем Image(или любым другим). **Перейдем в склонированную директорию** и выполним

```
$ cp kernels/Image_6.16_wifi_rt /путь/до/BOOT/Image
```

Далее, положим туда же скомпилированный файл device tree из репозитория(по такому же пути можно посмотреть и на исходный dts!).

```
$ cp dts_and_dtb/sun20i-d1-lichee-rv-dock.dtb /путь/до/BOOT/
```

Теперь, нужно создать конфигурационный файл для загрузчика, который сообщит ему, какое ядро запускать, с каким device tree и каким параметрами.

Можно его создать и написать самим, а можно скопировать уже готовую директорию из репозитория, и ознакомиться с содержимым.

```
$ cp -r extlinux /run/media/taranev/BOOT 
```
Минимальное содержимое:
```
label Linux
  kernel /Image
  fdt /sun20i-d1-lichee-rv-dock.dtb
  append root=/dev/mmcblk0p2 rootwait console=ttyS0,115200
```
Кратко расскажу про указанные параметры:

- *kernel /Image* — путь к ядру на разделе BOOT
- *fdt /sun20i-d1-lichee-rv-dock.dtb* — путь к .dtb на разделе BOOT
- *root=/dev/mmcblk0p2* — указывает, где искать корневую файловую систему
- *rootwait* — ждет, пока SD-карта инициализируется, без этого может не найти rootfs
- *console=ttyS0,115200* — нужен, чтобы получать отладочную информацию о запуске через UART


### Раздел ROOTFS

На этот раздел нам нужно распаковать содержимое, которое полностью соответствует заданной метке раздела. 

Перейдем на [страницу регулярных сборок altlinux для riscv64](https://www.altlinux.org/Regular/riscv64) и выберем тарболл по душе и возможностям платы. По хорошему, наверное стоило бы выбрать jeos-systemd, как самый легкий вариант, но я остановлюсь на более привычном мне [xfce](https://nightly.altlinux.org/sisyphus-riscv64/current/regular-xfce-latest-riscv64.tar.xz).

Распакуем архив прям на раздел ROOTFS:

```
$ sudo tar -xJpf /путь/до/rootfs.tar.xz -C  /путь/до_раздела/ROOTFS/
```

Готово! Можно пробовать вставлять sd-карту в разъем одноплатника, перед извлечением кардридера не забудьте про вызов команды **sync**, подключаться к пинам UART с помощью переходника и наблюдать за процессом запуска.

Если все получилось, вы вошли в систему и одноплатник выполняет возложенный на него функционал, можно, по желанию сохранить результат в виде .img образа операционной системы. 

$ cat /dev/sdX > imagefile.img

