# Подробнее об образах ОС

По мере погружения в разработку под одноплатники у меня начал нарастать интерес по устройству механизма развертывания операционной системы на плате.

Я уже демонстрировал в подразделе ["Установка образа операционной системы"](#install) самый простой вариант записи образа на носитель.

Там я использовал уже подготовленный для lichee_rv образ с кастомным ядром 6.1.0-d1-un-alt. Запуск с данным образом позволяет использовать всю необходимую перефирию: сеть и графику(хотя ее этому одноплатнику ой как тяжело тащить).

Но вообще, существуют и [регулярные сборки для riscv64](https://www.altlinux.org/Regular/riscv64) с более актуальным ядром. Другое дело, что интересующий нас SoC поддерживает регулярные сборки только теоретически. На деле, запись такого образа на lichee_rv позволит работать в системе, но без графики и сети, что ну..неудобно.

Кстати говоря, в статьях про [регулярные сборки](https://www.altlinux.org/Regular) и [регулярные сборки для riscv](https://www.altlinux.org/Ports/riscv64) упоминается инструмент [alt-rootfs-installer](https://www.altlinux.org/Write/rootfs). Использование данного инструмента позволяет легко запустить на плате Alt Linux с различными графическими оболочками. Для этого достаточно иметь архив с корневой файловой системой, а загрузчик и ядро, которое **запуститься** на нужном вам поддерживаемом устройстве утилита определит и поставит сама.

## Оглавление
- [Постановка задачи](#take_task)
- [Сборка ядра](#take_task)
- [Device Tree](#device_tree)
- [Загрузчик](#bootloader)
- [rootfs](#rootfs)

<a name="take_task"></a>

## Постановка задачи

Но все таки, мне хотелось бы понять и разобраться в технологии создания образа глубже. Собственно поделюсь тем, что узнал на данный момент.

Итак, что же нам нужно, чтобы получить образ с *нужным нам ядром, файловой системой и перефирией*:

 - архив с корневой файловой системой(rootfs)
 - исходники ядра(kernel source)
 - собранный u-boot
 - make и прочие сборочные зависимости
 - кросс-компилятор

 Теперь заново уконкретизирую задачу, чтобы было проще выстроить повествование. Я(мы!) хочу собрать образ **ALT Linux** для платы **Lichee RV** с более-менее свежим ядром, работающим wifi-модулем 

Отлично, возьмем [кросс-компилятор из репозитория](#cross-compiler), [регулярную сборку rootfs](https://www.altlinux.org/Regular/riscv64), заботливо собранный добрыми людьми, [готовый для работы u-boot](https://packages.altlinux.org/ru/sisyphus_riscv64/srpms/u-boot-sunxi-riscv/)(а иначе самому бы пришлось собирать!), [исходники ядра 6.16](https://packages.altlinux.org/ru/sisyphus/srpms/kernel-source-6.16/).


В случае необходимости установить ОС «Альт» на устройство без реализованных BIOS или EFI требуется дополнительный загрузчик. В основном для этой цели используется u-boot. Он берет на себя первоначальную инициализацию необходимых для загрузки устройств, загружает в память ядро linux, возможные initrd и dtb и передает управление ядру. Эта составляющая у нас уже есть. Останется только записать его на флеш-карту. Но об этом позже.

<a name="kernel compilation"></a>

## Сборка ядра

Далее, наверное, самая интригующая часть: сборка ядра. 

Сборка ядра Linux из исходных кодов — это процесс компиляции и компоновки исходного кода ядра в исполняемые файлы (ядро и загружаемые модули) на основе предоставленной вами конфигурации.

Предварительно, установим необходимые пакеты:

```
# apt-get install wget build-essential bc flex bison u-boot-tool ncurses-devel openssl libssl-devel dtc
```

Архив с исходным кодом получим в папке */usr/src/kernel/sources/kernel-source-6.16.tar*, установив соответствующий пакет.

Для этого переключимся на репозиторий [Sisyphus](https://www.altlinux.org/%D0%A7%D1%82%D0%BE_%D1%82%D0%B0%D0%BA%D0%BE%D0%B5_Sisyphus%3F) и выкачаем из него архивы с пакетами.
```
# apt-repo rm all

# apt-repo set sisyphus

# apt-get update
```
А затем установим нужный пакет

```
# apt-get install kernel-source-6.16
```

Распакуем в удобное место архив и перейдем в его корневую папку.

Далее, нам будет необходимо сконфигрировать файл .config, который собирает в себя все возможные параметры для сборки ядра.

Существует несколько способов создания такого файла. Воспользуемся классическим интерфейсом для make. Выполним
```
$ make menuconfig
```

Откроется интерактивный интерфейс для тонкой настройки, который позволяет представить древовидную структуру всех опций ядра (драйверы устройств, поддержка файловых систем, сетевые функции и т.д.) и выбирать нужные.

В menuconfig все навигируется стрелками. Выбор опций осуществляется с помощью Enter, включение (Y), выключение (N), установка опции как модуль (M) осуществляется с помощью соответствующих клавиш. Кроме того может пригодиться поиск нужных опций конфигурации и их зависимостей (/).

По завершении выбора нужных настроек все сохраняется в файл конфигурации .config.

Приведу пример включения параметра PREEMPT_RT, отвечающего за включение в ядро модуля поддержки мягкого реального времени.

Для начала, можно в файл .config включить стандартную конфигурацию ядра, которая заполнит все параметры и теоретически позволяет запуститься ядру на любом устройстве указанной архитектуры. Сделать это можно так. 

```
$ make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- defconfig
```
Эта команда готовит исходный код ядра Linux к сборке для архитектуры RISC-V, используя кросс-компиляцию. Рассмотрим подробнее, что мы передали в качестве аргументов и что будет выполнено в результате.

**ARCH=riscv** указывает целевую архитектуру процессора, для которой мы собираем ядро. Исходный код ядра Linux поддерживает десятки архитектур (x86_64, arm, arm64, powerpc, riscv и т.д.). Код, специфичный для каждой архитектуры, лежит в разных поддиректориях (например, arch/x86/, arch/arm/, arch/riscv/). Переменная ARCH говорит утилите make и системе сборки, к какой из этих директорий обращаться для поиска правильных исходников, конфигураций и правил сборки.

В данном случае мы говорим системе — "собирай не для моей родной архитектуры (скорее всего, x86_64), а для RISC-V".

**CROSS_COMPILE=riscv64-linux-gnu-** задает префикс для набора инструментов компилятора (toolchain), который используется для кросс-компиляции.

Для этого нужен специальный компилятор — кросс-компилятор. Его бинарные файлы обычно имеют префикс, указывающий на целевую архитектуру.

**riscv64-linux-gnu-** — это и есть тот самый префикс. Система сборки будет вызывать не просто gcc, а riscv64-linux-gnu-gcc; не ld, а riscv64-linux-gnu-ld и так далее. Об установке нужного кросс-компилятора прочитать можно [здесь](#cross-compiler).

**defconfig** — это цель (target) для make. Она генерирует базовый конфигурационный файл (.config) для выбранной архитектуры.

В директории arch/<arch>/configs/ (в нашем случае arch/riscv/configs/) лежат несколько заранее подготовленных конфигурационных файлов. defconfig — это обычно конфигурация по умолчанию для данной архитектуры. Она включает все необходимые опции для базовой работоспособности ядра на большинстве устройств с этой архитектурой, но без специфичных драйверов для какого-то конкретного железа.

Выполнение этой цели скопирует конфиг из arch/riscv/configs/defconfig в корневую директорию с исходным кодом ядра и сохранит его как файл .config, что и станет отправной точкой для нашей настройки.

Произведем донастройку получившейся конфигурации.

```
$ make ARCH=riscv menuconfig
```

P.S указание архитектуры здесь необходимо для того, чтобы система сборки обратилась к директории arch/riscv/ для получения всех архитектурно-зависимых настроек, списков плат и драйверов.

Итак, мы в графическом меню, и нам необходимо включить параметр *PREEMPT_RT* для того, чтобы добавить соответствующий модуль ядра в конфигурацию. Жмем (/) и пишем название параметра в появившееся поле ввода.

![alt text](/pictures/search_in_menuconfig.png)

Получив такой вывод можно сделать вывод о том,где в дереве расположен параметр и какие параметры с какими значениями нужно установить для возможности включения целевого параметра. В нашем случае необходимо чтобы параметр *EXPERT* был включен(он выключен), параметр *ARCH_SUPPORTS_RT* был включен(уже), а параметр *COMPILE_TEST* был отключен(тоже уже так).

Включив параметр *EXPERT* и найдя по указанному пути расположение параметра *PREEMPT_RT* мы получим желаемое.

Аналогично для того, чтобы обеспечить работу wifi-модуля Realtek 8723DS нужно будет найти и включить параметры RTW88_RTL8723DS. Кроме того, понадобиться указать в конфигурации, что сборка ведеся для платы с процессором Allwinner D1 от компании Sunxi, и включить поддержку различных аппаратных микросхем для нашей платы от компании Lichee RV.

*На момент публикации коммита (10.09.2025) у меня не вышло обеспечить работу wifi на плате. Но это, видимо связанно с неправильным device-tree, о чем расскажу подробнее позже.*

На данный момент я создал [репозиторий](https://github.com/Besogon1238/Researches_for_Lichee_RV), в котором складываю **все, что пригодилось мне или может пригодиться для сборки образа под Lichee RV**. Там будет все, кроме содержимого директории сборки ядра(она же первоначально директория с исходниками). В частности, сейчас там можно найти уже готовый конфиг для сборки ядра и образы самих ядер.

По завершении указанных действий, можно произвести попытку запуска сборки командой.

```
$ make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- -j$(nproc)
```

Возможно, при этом make через CLI начнет задавать множество вопросов о конфигурации параметров, значение которых не было задано. Для этого предварительно нужно поменять конфиг, вызвав make с командой *olddefconfig*. В таком случае в наш конфиг для всех незаполненных параметров будут применены значения по умолчанию, как в defconfig.

Так что обобщенный порядок действий для нашего случая можно описать так:

```
$ cd ~/директория/сборки/

# загрузили в .config конфиг по умолчанию
$ make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- defconfig

# сделали специфичные изменения
$ make ARCH=riscv menuconfig

# (опционально) заполнили активные, но не установленные параметры значениями по умолчанию

$ make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- olddefconfig

# запустили сборку ядра

$ make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- -j$(nproc)
```

После окончания сборки по пути *arch/riscv/boot/* можно будет найти бинарный файл готового ядра, а также его сжатый вариант с расширеним .gz. Кроме того в других подкаталогах будут сгенерированы внешние модули ядра.

<a name="device_tree"></a>

## Device Tree

После завершения сборки, в зависимости от того, поддержка каких SoC была выбраны в соответствующем разделе дерева параметров в директории сборки по пути *arch/архитектура/boot/dts/производитель* из файлов .dts будут скомпилированы файлы .dtb.

Статья на altlinux.org [прилагается](https://www.altlinux.org/Device_Tree).

Введу лишь несколько определений.

**Device Tree (DТ)** — это структура данных, которая описывает "железо" системы  для операционной системы. Позволяет одному ядру ОС работать на разных устройствах без перекомпиляции.

**DTS (Device Tree Source)** — исходный, человекочитаемый текстовый файл с описанием устройства (.dts или .dtsi для include-файлов).

**DTB (Device Tree Blob)** — бинарный, скомпилированный файл (.dtb), который загружается ядром ОС.

Основной источник(ресурс) dts — исходники ядра Linux и репозитории разработчиков железа. Файлы .dts лежат по пути arch/архитектура/boot/dts/производитель/ (например, arch/riscv/boot/dts/allwinner).

**Как такое написать самому?**
Если вдруг в наличии подходящего .dts файла нету, то нужно будет найти и изучить Datasheet для вашего SoC. Это главный источник информации об адресах периферии и их регистрах.

Вариант упрозения такой задачи, который пришел мне в голову - найти .dts файл для максимально похожего устройства в исходниках ядра и с ним уже что то придумывать. Я попробовал — и пока забросил это дело...ведь все что нужно для нашего случая уже есть. Но вообще мне показалось, что задача эта не из простых.

Поскольку у меня в распоряжении плата Lichee RV **Dock**, и в исходниках ядра есть device tree от производителя, проблем с написанием исходного файла нет.

Остается лишь после сборки ядра взять необходимый .dtb файл из пути *../директория_сборки/arch/riscv/boot/dts/allwinner*

<a name="bootloader"></a>

## Загрузчик

Загрузчик (bootloader) — это небольшая программа, которая запускается сразу после включения устройства и отвечает за базовую инициализацию железа (процессор, память, диски),поиск и загрузку в память основной операционной системы (ядра Linux),передачу управления этой операционной системе.

Для одноплатников самым распространенным загрузчиком является Das U-Boot(или просто U-Boot).

Стоит описать схему запуска одноплатника по пунктам:

#### Включение питания (Power-On):

Процессор "просыпается" и начинает выполнять код из зашитой в чип памяти (ROM). Этот код очень простой и его задача — найти и запустить следующий этап загрузки (обычно с SD-карты или флешки).

#### Этап 1: U-Boot (SPL или U-Boot Proper):

Первым делом запускается U-Boot. Часто он разделен на две части:

SPL (Secondary Program Loader): Миниатюрная версия U-Boot, которая инициализирует ОЗУ (DRAM). Без этого нельзя загрузить полную, "тяжелую" версию загрузчика.

U-Boot Proper: Полноценный U-Boot, загруженный в память. Он инициализирует периферию (USB, сеть, SD-карту и тд.), находит на файловой системе образ ядра Linux, device tree (файл с описанием "железа" платы) и образ OpenSBI (обычно fw_dynamic.bin).

#### Этап 2: OpenSBI:

Так, секунду...**а что это?** 

OpenSBI (Open Supervisor Binary Interface) — это реализации спецификации SBI (Supervisor Binary Interface). Этот стандарт определяет интерфейс между программной средой выполнения(M-mode) и супервизором(S-mode). 

Звучит, как что-то непонятное. Как я понял,  есть привилегированный режим процессора(M-mode), который работает "на железе" напрямую и как раз в нем работает OpenSBI. А есть менее привилегированный режим, в котором работает ядро ОС.

U-Boot загружает образ OpenSBI в память и передает ему управление.

OpenSBI работает в привилегированном режиме M-mode. Он выполняет финальную низкоуровневую инициализацию процессора (например, настраивает обработку прерываний) и готовит окружение для запуска ядра ОС в менее привилегированном режиме (S-mode).

#### Этап 3: Передача управления ядру Linux:

OpenSBI выступает в роли "доверенного посредника" (supervisor). Он переключает процессор в режим S-mode и передает управление ядру Linux, которое было загружено U-Boot'ом.

При этом OpenSBI остается в памяти. Когда ядру Linux нужно выполнить привилегированную операцию (например, перезагрузить систему), оно не делает это само, а делает системный вызов (ecall) к OpenSBI, который уже выполняет нужное действие на аппаратном уровне.

#### Запуск ОС:

Ядро Linux инициализируется, монтирует корневую файловую систему и запускает процесс init. После этого система загружена и готова к работе. 

<a name="rootfs"></a>

Зачастую, u-boot для устройства в том или ином виде создает производитель платы. Это может быть, как готовый u-boot, так и исходники, которые нужно собрать.

На сайте самого проекта u-boot есть раздел посвященный микропроцессорам Allwinner и на нем предложен [способ сборки u-boot](https://docs.u-boot.org/en/latest/board/allwinner/sunxi.html#building-the-u-boot-image). Возможно, я к этому еще вернусь.

Но сейчас мы возьмем уже готовый u-boot с OpenSBI версии 1.7 из [репозитория](https://packages.altlinux.org/ru/sisyphus_riscv64/binary/u-boot-sunxi-riscv/noarch/3229656311355752582).

Для этого переключимся на репозиторий sisyphus_riscv64, если сейчас он не выбран

```
# nano /etc/apt/sources.list
```

И вместо текущего содержимого вставляем

```
rpm [sisyphus-riscv64] http://ftp.altlinux.org/pub/distributions/ALTLinux/ports/riscv64 Sisyphus/riscv64 classic

rpm [sisyphus-riscv64] http://ftp.altlinux.org/pub/distributions/ALTLinux/ports/riscv64 Sisyphus/noarch  classic
```

Скачаем архивы пакетов и установим нужный пакет

```
# apt-get update

# apt-get install u-boot-sunxi-riscv
```

Загрузчики для устройств на базе Allwinner D1 после этого окажутся по пути */usr/shere/u-boot*.

Если после этого пакетная база репозитория вам не нужна, можно вернуться с помощью apt-repo к архивам вашей используемой на основной системе ветки репозитория.

В следющем подразделе будет приведен конкретный пример его установки на sd-карту.



## rootfs

**Rootfs (Root Filesystem)** — это корневая файловая система. Это основа, с которой начинает работать любая Unix-подобная операционная система (включая Linux) после загрузки ядра.

Проще говоря, это главный иерархический каталог, который содержит всё необходимое для работы системы: исполняемые программы(/bin /sbin /usr/bin), библиотеки(/lib /usr/lib), конфигурационные файлы(/etc), виртуальные файлы устройств(/dev), временные файлы(/tmp), точки монтирования(/mnt /run/media), домашние катологи пользователей(/home) и многое другое.

На одноплатном компьютере rootfs выполняет абсолютно те же важные функции, что и на сервер или ПК.

- Запуск первой программы (init) и пользовательских приложений.

После того как ядро Linux загружено загрузчиком (U-Boot) и распаковано в память, оно ищет в rootfs программу для запуска под номером 1. Эта первая программа запускает все остальные сервисы, демоны, и приложения.

- Предоставление среды для работы.

Без корневой файловой системы у ядра не будет доступа к критически важным библиотекам (например, libc), конфигурационным файлам (сетевым настройкам, паролям) и самим программам.

Ядро само по себе — просто механизм, менеджер ресурсов. А вся функциональность и пользовательский интерфейс содержатся в rootfs.

- Управление системой и её конфигурация.

Все настройки одноплатника (сетевые адреса, параметры запуска, пароли пользователей и многое другое) хранятся в файлах внутри rootfs (в основном в /etc). Чтобы что-то изменить в работе системы, нужно изменять содержимое rootfs.

За примерами установки rootfs из архива на SD-карту или преобразования архива в готовый img-образ для конкретной платы с помощью alt-rootfs-installer предлагаю обратиться по ссылке[ в начало дневника](/Subpages/Start.md#install).

Я же приведу конкретный пример его установки в следующей [главе](/Subpages/Create_images.md)).







