# Добавление поддержки SPI в образ для Lichee RV Dock

В процессе работы с Lichee RV Dock у меня появилась задача сделать возможным работу с SPI-интерфейсом микроконтроллера, что стало неожиданно не самой простой задачей. На текущий момент о своих долгих попытках я решил изложить на этой странице.


## Краткая теория о самом интерфейсе

SPI (Serial Peripheral Interface) — это интерфейс для связи с периферийными устройствами, такими как датчики, преобразователи и память.

![alt text](/pictures/SPImult.png)

Его работа строится по принципу «ведущий-ведомый», где ведущий задаёт такт синхронизации (SCK). По одному проводу (MOSI) данные идут от ведущего к ведомому, а по другому (MISO) — обратно. Это позволяет передавать информацию в обе стороны одновременно. Однако важно помнить, что при каждой записи команды или данных вы всегда получите ответ такой же длины от ведомого устройства, даже если это ответ не несёт полезной информации.

Классическая схема подключения, приведенная на рисунке выше, является параллельной: все ведомые устройства совместно используют линии данных (MOSI, MISO) и тактирования (SCK). Единственным исключением является сигнал выбора ведомого (~CS), который для каждого устройства должен быть индивидуальным. На рисунке эти сигналы обозначены как SSx. Для их формирования можно использовать как специализированные выводы SPI-контроллера, так и универсальные GPIO-пины.

В случае с платой Lichee RV Dock базово предоставляется возможность подключить только одно SPI-устройство, что упрощает схему (см. рисунок ниже).


![alt text](/pictures/SPI.png)

Интерфейс SPI применяется преимущественно во встроенных системах и электронных устройствах для короткой дистанции, обеспечивая высокоскоростной синхронный обмен данными между микроконтроллером (мастером) и периферийными микросхемами (ведомыми). Основные цели его использования — подключение и управление разнообразной периферией, такой как датчики (температуры, давления, акселерометры), карты памяти (SD, MMC), ЦАП/АЦП, сдвиговые регистры, драйверы дисплеев и тд.


## Постановка задачи

Вспомним и сформулируем цель: **обеспечить возможность взаимодействия с SPI-интерфейсом микроконтроллера Allwinner D1 из пользовательского пространства операционной системы**.

Сформулировали. Отлично! Но в чем проблема?

А первую проблему можно увидеть, если обратиться к [распиновке](/pictures/pinout.png) или [схеме](/pictures/Scematic.pdf]) изучаемой платы.

Взглянем на распиновку(или на более подробную схему):

![alt text](/pictures/pinout.png)

Можно заметить, что SPI интерфейс выведен на GPIO-гребенку в качестве дополнительной, а не стандартной функции. Что означает, что по умолчанию ножки процессора, выведенные на указанные пины будут использоваться для работы с RGB-экраном.

Следовательно, первую задачу, которую необходимо решить можно сформулировать так: *"Необходимо сообщить ядру операционной системы об использовании пинов микроконтроллера для работы SPI-интерфейса".* 

Следующая проблема вытекает из первой. Звучит она так: "А какие драйверы ядра могут обеспечить поддержку интерфейса?". И это весьма неочивидная в своей сути проблема, которая будет раскрыта в полной мере позже: в конфигурации ядра и в его исходниках просто не существует драйвера, обеспечивающего поддержку SPI-интерфейса для семейства микроконтроллеров sun20i(Allwinner D1).

Вторую задачу сформулируем так: "Необходимо добавить в ядро драйверы, которые обеспечат работу интерфейса SPI в пользовательском пространстве". 

## Необходимые шаги

Если несколько отступить от необходимых шагов для достижения поставленной цели, то можно упомянуть о том, что на самом деле на решение озвученных проблем меня ушло практически 2 недели... Само собой настолько долгий простой связан не со сложностью задач, а с моей базовой некомпетентностью, которая не позволила осуществить все быстрее.

С другой стороны, решение этой, на первый взгляд, тривиальной задачи позволило мне гораздо лучше изучить процесс работы Linux с hardware и драйверами, и, думаю, осуществить работу других популярных интерфейсов мне будет уже гораздо проще.

А теперь перечислим все шаги реализации:
    - Добавление и активация интерфейса в Device Tree
    - Добавление драйвера поддержки интерфейса SPI в ядро
    - Добавление сопутствующих драйверов 

## Путь решения

### Добавление и активация интерфейса в Device Tree

Для начала стоит коротко пояснить, как при сборке ядра формируются бинарные .dtb файлы из исходников дерева устройств. Все довольно просто, рассмотрим на примере lichee_rv_dock.

В папке исходников ядра по пути *arch/riscv/boot/dts/allwinner/* лежат исходники дерева устройств для одноплатников на чипе Allwinner D1.

Если открыть файл [*sun20i-d1-lichee-rv-dock.dts*](https://github.com/Besogon1238/Researches_for_Lichee_RV/blob/main/dts_and_dtb/sun20i-d1-lichee-rv-dock.dts), то можно заметить в самом начале включение в него аналогичного файла [*sun20i-d1-lichee-rv.dts*](https://github.com/Besogon1238/Researches_for_Lichee_RV/blob/main/dts_and_dtb/sun20i-d1-lichee-rv.dts)для более "голой" версии одноплатника. В свою очередь, в этом файле можно тоже обнаружить включение файлов с более общими параметрами. Пройдя весь цикл таких вложенностей можно наконец добраться до файла [*sunxi-d1s-t113.dtsi*](https://github.com/Besogon1238/Researches_for_Lichee_RV/blob/main/dts_and_dtb/sunxi-d1s-t113.dtsi),в котором и содержится объявление всех возможных интерфейсов и устройств, которые могут поддерживаться устройствами на базе микроконтроллера D1. По сути говоря такие файлы формата .dtsi являются заголовочными файлами для исходных файлов формата .dts. Буква *i* в названии и означает слово *include*.

Найдем объявления связанные с SPI в заголовочном файле.

**Объявление пинов микроконтроллера**, которые поддерживают работу двух SPI интерфейсов(spi0 и spi1). Убедится в полном соответствии исходников реальности можно, взглянув на более подробную [схему одноплатника]((/pictures/Scematic.pdf])).

```
/omit-if-no-ref/
spi0_pins: spi0-pins {
        pins = "PC2", "PC3", "PC4", "PC5";
        function = "spi0";
};

/omit-if-no-ref/
spi1_pb_pins: spi1-pb-pins {
        pins = "PB0", "PB8", "PB9", "PB10", "PB11", "PB12";
        function = "spi1";
};

/omit-if-no-ref/
spi1_pd_pins: spi1-pd-pins {
        pins = "PD10", "PD11", "PD12", "PD13", "PD14", "PD15";
        function = "spi1";
};
```

P.S директива */omit-if-no-ref/* в данном случае необходима для невключения в готовый .dtb файл тех объектов, которые ни разу после объявления нигде не упоминаются.

**Объявление SPI интерфейсов**,в которых указано с какими аппаратными прерываниями, интерфейсами и железом должен пользоваться интерфейс:

```
spi0: spi@4025000 {
        compatible = "allwinner,sun20i-d1-spi",
                        "allwinner,sun50i-r329-spi";
        reg = <0x4025000 0x1000>;
        interrupts = <31 IRQ_TYPE_LEVEL_HIGH>;
        clocks = <&ccu CLK_BUS_SPI0>, <&ccu CLK_SPI0>;
        clock-names = "ahb", "mod";
        resets = <&ccu RST_BUS_SPI0>;
        dmas = <&dma 22>, <&dma 22>;
        dma-names = "rx", "tx";
        num-cs = <1>;
        status = "disabled";
        #address-cells = <1>;
        #size-cells = <0>;
};

spi1: spi@4026000 {
        compatible = "allwinner,sun20i-d1-spi-dbi",
                        "allwinner,sun50i-r329-spi-dbi",
                        "allwinner,sun50i-r329-spi";
        reg = <0x4026000 0x1000>;
        interrupts = <32 IRQ_TYPE_LEVEL_HIGH>;
        clocks = <&ccu CLK_BUS_SPI1>, <&ccu CLK_SPI1>;
        clock-names = "ahb", "mod";
        resets = <&ccu RST_BUS_SPI1>;
        dmas = <&dma 23>, <&dma 23>;
        dma-names = "rx", "tx";
        num-cs = <1>;
        status = "disabled";
        #address-cells = <1>;
        #size-cells = <0>;
};
```

Интересным для нас полем впоследствии станет параметр **compatible**, в котором указываются названия драйверов,которые поддерживают работу с тем или иным устройством. При чем, первым в последовательности указывается тот драйвер, которым устройство и нужно инициализировать в первую очередь.

При загрузке ядра драйвера вычитывают из этого поля у активных устройств строку и при обнаружении поддерживаемого устройства вызывают функцию probe для инициализации устройства в ОС.

Можно заметить, что статус обоих устройств говорит о том, что устройство отключено. Этот факт нам предстоит исправить в [исходном файле](https://github.com/Besogon1238/Researches_for_Lichee_RV/blob/main/dts_and_dtb/sun20i-d1-lichee-rv-dock.dts) платы. На текущем этапе в нем нет ничего связанного с SPI.

Итак, добавим в конец файла следующее:

```
&spi1 {
        pinctrl-0 = <&spi1_pd_pins>;
        pinctrl-names = "default";
        status = "okay";
};
```

Данной записью мы определеям или переопределяем описанные параметры. В первую очередь, мы объявляем интерфейс включенным и указываем, на каких именно пинах будет идти обмен.

На самом деле, это не последнее внесенное в исходный файл дерева устройств изменение. Здесь нужно забежать несколько вперед и упомянуть, что все изначально было сделано ради получения возможности из пользовательского пространства работать с SPI интерфейсом. Такой функционал в Linux обеспечивает отдельный драйвер  **SPIDEV**.
Его поддержку необходимо будет добавить в конфиг сборки ядра(параметр SPI_SPIDEV). Кроме того, исходя из [наиболее актуальной документации](https://www.kernel.org/doc/html/latest/spi/spidev.html) к драйверу для того, чтобы устройство было подхвачено драйвером необходимо чтобы оно присутствовало в одной из трех таблиц устройств, жестко заданных внутри исходного кода драйвера. Наше устройство естественно в такой таблице не присуствует. 

В зависимости от ваших предпочтений можно поступить двумя способами: либо добавить свое устройство в одну из этих таблиц и скомпилировать измененный драйвер для ядра, либо в поле .compatible, указываемое при объявлении символьного устройства в Device Tree указать то устройство, которое в этих таблицах уже есть.

Я выбрал второй способ:

```
&spi1{
        pinctrl-0 = <&spi1_pd_pins>;
        pinctrl-names = "default";
        status = "okay";
        spidev0: spidev@0 {
            compatible = "rohm,dh2228fv";
            spi-max-frequency = <100000000>;
            reg = <0x00>;
    };
```

На этом преобразовании Device Tree окончено.

### Добавление драйвера поддержки интерфейса SPI в ядро 

В качестве стартовой точки на этом шаге у меня был собственный конфиг для ядра, который был получен привнесением изменений в defconfig для Lichee RV Dock. Кстати найти его можно [здесь](https://github.com/Besogon1238/Researches_for_Lichee_RV/tree/main/configs_for_kernel_6.16/.config_for_6.16_lichee_rt_gpio).

В нем кстати поддержка самой возможности для ядра работать с SPI интерфейсами уже была включена(параметры SPI и SPI_MASTER). Но этого конечно же недостаточно. Как минимум необходим был драйвер для работы конкретно на нашем SoC, которого... не существует.

"Как же так?" может появится вопрос у прочитавшего предыдущий пункт. Ведь даже в заголовочном файле Device Tree в поле *compatible* у обоих интерфейсов были указаны соответствующие названия драйверов!

Ну...здесь история немного темная, но если разобраться в том, как названия этих драйверов появились там, можно узнать, что конкретным пользователем был предложен патч, добавляющий поддержку SPI для ряда семейств процессоров от компании Allwinner. С описанием внесенных изменений можно ознакомиться [здесь](https://lwn.net/Articles/931179/). 

Исходя из описанного поддержка SPI была осуществлена путем добавления необходимых объектов в device tree и внесением изменений в драйвер spi-sun6i.c, который иначально был предназначен для устройств семейства микроконтроллеров на архитектуре arm. Но ввиду практически идентичной реализации SPI-интерфейса было принято решение добавить в этот же драйвер поддержку еще нескольки семейств, в числе которых было и семейство sun20i.

В сухом остатке оставалось только добавить поддержку этого драйвера в конфиг ядра(SPI_SUN6I).

### Добавление сопутствующих драйверов

В процессе попыток заставить драйвер *SPI_SUN6I* выяснилось, что инициализировать устройство у драйвера не получается, поскольку у него не получается получить доступ к DMA каналам. В ходе мыслительной деятельности появилась идея о том, что драйверу SPI для другого семейства микроконтроллеров может не хватать драйвера DMA для этого же семейства. Иии...да! Ровно так и оказалось! Добавление драйвера *DMA_SUN6I* наконец таки позволило добиться желаемого результата.

## Финал

В качестве результата можно порадоваться, обнаружить в каталоге /dev/ символьное spidev устройство и протестировать работу интерфейса самым тривиальным способом, замкнув MOSI и MISO пины друг на друга, а затем запустить простой тест на питоне.

```
import spidev
import time

def spi_sequential_test(bus=0, device=0, speed=1000000):
    try:
        spi = spidev.SpiDev()
        spi.open(bus, device)
        spi.max_speed_hz = speed
        spi.mode = 0
        spi.lsbfirst = False


        print("SPI последовательный тест запущен...")
        print("Отправляю данные: 0, 1, 2, 3, ...")
        print("-" * 40)

        for i in range(256):  # От 0 до 255
            # Отправляем одно число и получаем ответ
            data_to_send = [i]
            response = spi.xfer2(data_to_send)

            print(f"Отправлено: {data_to_send[0]:3d} (0x{data_to_send[0]:02X}) | "
                  f"Получено: {response[0]:3d} (0x{response[0]:02X}) | "
                  f"Бинарно: {response[0]:08b}")

            time.sleep(0.01)  # Небольшая пауза для анализатора

        spi.close()

    except Exception as e:

# Запуск теста
if __name__ == "__main__":
    # Настройте под вашу плату
    spi_sequential_test(bus=0, device=0, speed=1000000)


```

Результат:

![alt text](/pictures/SPI_result.png)


P.S Надо бы попробовать протестировать работу на каком нибудь SPI экранчике, что я обязательно постараюсь сделать в ближайшее время.



# Добавление поддержки I2c в образ для Lichee RV Dock
