# Подсказка для семинара

Если вы попали на семинар,то вам уже доступно учетная запись с правами админстратора. **Логин demo, пароль demo.**

## Подключение к плате

Если вы успешно добились повторения картинки ниже, то самое время запустить плату!

![UART-преобразователь](/pictures/соелинение%20переходника%20с%20GPIO%20ПЛАТЫ.jpg)

Чтобы определить имя устройства в системе можно почитать логи dmesg. Например так:

```
dmesg | grep -i "tty"
```

Подключимся к UART-преобразователю, и ждем поступления сигналов

```
$ tio -b 115200 /dev/ttyUSBX
```

Теперь **если вставить флеш-карточку с записанной на нее образом в соответствующий интерфейс на плате и подключить питание**, можно увидеть в консоли логи запуска операционной системы, а затем и приглашение ко вводу.

На всех регулярных сборках ALT регулярных сборках, до прохождения мастера первоначальной настройки, логинка *root* с паролем *altlinux*.

Дальше можем подключиться к wifi в нашей лаборатории:

```
nmcli dev wifi list
nmcli dev wifi connect alt password "BaseALT2024"

ping ya.ru

```

Можно даже посмотреть на графику!

## Постановка задачи

Попробуем понять и разобраться в технологии создания образа глубже. 

Итак, что же нам нужно, чтобы получить образ с *нужным нам ядром, файловой системой и перефирией*:

 - архив с корневой файловой системой(rootfs)
 - исходники ядра(kernel source)
 - собранный u-boot
 - make и прочие сборочные зависимости
 - кросс-компилятор

 **Если вы участник воркшопа, то для вас все это уже приготовлено :)**

 Теперь заново уконкретизирую задачу, чтобы было проще выстроить повествование. Мы хотим собрать образ **ALT Linux** для платы **Lichee RV Dock** с более-менее свежим ядром, патчем ядра PREEMPT_RT(позволяющий реализовать мягкое реальное время) и поддержкой работы wifi-модуля.
  
Оговорюсь, что на практике будет продемонстрировано только добавления патча PREEMPT_RT.

## Работа с компонентами образа

В хомяке(/home/demo) будет находиться директория demo. Это директория, в которой мы и будем работать.

Перейти в директорию:

```
cd ~/demo
```

В этой директории должно находиться еще 2 директории и архив. Посмотрим на них с помощью ls:

```
ls
```

В директории **kernel-source-6.16** у нас находятся исходники ядра линукс 6.16, в директории **Researches_for_Lichee_RV** лежат уже готовые компоненты для нашего образа. Архив же содержит корневую файловую систему, но обо всем этом позже.

### Сборка ядра

Далее, наверное, самая интригующая часть: сборка ядра. 


**Сборка ядра Linux** из исходных кодов - это процесс компиляции и компоновки исходного кода ядра в исполняемые файлы (ядро и загружаемые модули) на основе предоставленной вами конфигурации.


```
$ make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- defconfig
```
Эта команда готовит исходный код ядра Linux к сборке для архитектуры RISC-V, используя кросс-компиляцию. Рассмотрим подробнее, что мы передали в качестве аргументов и что будет выполнено в результате.

Выполнение этой команды скопирует конфиг из arch/riscv/configs/defconfig в корневую директорию с исходным кодом ядра и сохранит его как файл .config, что и станет отправной точкой для нашей настройки.

Произведем донастройку получившейся конфигурации.

```
$ make ARCH=riscv menuconfig
```

P.S указание архитектуры здесь необходимо для того, чтобы система сборки обратилась к директории arch/riscv/ для получения всех архитектурно-зависимых настроек, списков плат и драйверов.

Итак, мы в графическом меню, и нам необходимо включить параметр *PREEMPT_RT* для того, чтобы добавить соответствующий модуль ядра в конфигурацию. Жмем (/) и пишем название параметра в появившееся поле ввода.

![alt text](/pictures/search_in_menuconfig.png)

Получив такой вывод можно сделать вывод о том,где в дереве расположен параметр и какие параметры с какими значениями нужно установить для возможности включения целевого параметра. В нашем случае необходимо чтобы параметр *EXPERT* был включен(он выключен), параметр *ARCH_SUPPORTS_RT* был включен(уже), а параметр *COMPILE_TEST* был отключен(тоже уже так).

Включив параметр *EXPERT* и найдя по указанному пути расположение параметра *PREEMPT_RT* мы получим желаемое.

По завершении указанных действий, можно произвести попытку запуска сборки командой.

```
$ make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- -j$(nproc)
```

Возможно, при этом make через CLI начнет задавать множество вопросов о конфигурации параметров, значение которых не было задано. Для этого предварительно нужно поменять конфиг, вызвав make с командой *olddefconfig*. В таком случае в наш конфиг для всех незаполненных параметров будут применены значения по умолчанию, как в defconfig.

Так что обобщенный порядок действий для нашего случая можно описать так:

```
$ cd ~/директория/сборки/

# загрузили в .config конфиг по умолчанию
$ make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- defconfig

# сделали специфичные изменения
$ make ARCH=riscv menuconfig

# (опционально) заполнили активные, но не установленные параметры значениями по умолчанию

$ make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- olddefconfig

# запустили сборку ядра

$ make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- -j$(nproc)
```

После окончания сборки по пути *arch/riscv/boot/* можно будет найти бинарный файл готового ядра, а также его сжатый вариант с расширеним .gz. Кроме того в других подкаталогах будут сгенерированы внешние модули ядра.

### Device Tree

После завершения сборки, в зависимости от того, поддержка каких SoC была выбраны в соответствующем разделе дерева параметров в директории сборки по пути *arch/архитектура/boot/dts/производитель* из файлов .dts будут скомпилированы файлы .dtb.

**На демо можно использовать содержимое папки Researches_for_Lichee_RV/dts_and_dtb/**

**Для нашего демо** нужно лишь взять уже готовый.dtb файл из пути *~/demo/Researches_for_Lichee_RV/arch/riscv/boot/dts/allwinner*

### Загрузчик 

Загрузчик для устройств на базе Allwinner D1 находятся по пути *~/demo/Researches_for_Lichee_RV/u-boot/lichee_rv_dock/*

### Extlinux configuration

Теперь, нужно создать конфигурационный файл для загрузчика, который сообщит ему, какое ядро запускать, с каким device tree и какимb параметрами.

Можно его создать и написать самим, а можно скопировать уже готовую директорию **extlinux** из папки **demo**.
```
Минимальное содержимое:
```
label Linux
  kernel /Image
  fdt /sun20i-d1-lichee-rv-dock.dtb
  append root=/dev/mmcblk0p2 rootwait console=ttyS0,115200
```
Кратко расскажу про указанные параметры:

- *kernel /Image* — путь к ядру на разделе BOOT
- *fdt /sun20i-d1-lichee-rv-dock.dtb* — путь к .dtb на разделе BOOT
- *root=/dev/mmcblk0p2* — указывает, где искать корневую файловую систему
- *rootwait* — ждет, пока SD-карта инициализируется, без этого может не найти rootfs
- *console=ttyS0,115200* — нужен, чтобы получать отладочную информацию о запуске через UART
```

### Раздел ROOTFS

Скачать подходящий нам rootfs можно [отсюда]](https://nightly.altlinux.org/sisyphus-riscv64/current/regular-xfce-latest-riscv64.tar.xz).

## Подготовка SD карты

Теперь можно описать процесс записи образа на sd-карту, заодно перечислив все необходимые компоненты.

Итак, начнем с того, что предварительно нам нужно будет изменить разбивку sd-карты, если такая присутствует.

Для этого предварительно затрем начало SD-карты нулями, при чем с запасом, чтобы гарантированно уничтожить таблицу разделов(10 МБ для этого вполне достаточно).

```
$ sudo dd if=/dev/zero of=/dev/sdX bs=1M count=10
```

Продолжим. Запустим утилиту fdisk и зададим разбиение на 2 раздела. После чего, я поясню наглядно, чего мы тем самым добились.

```
$ sudo fdisk /dev/sdX
```

```
o               # создаем новую DOS таблицу разделов
n               # новый раздел
p               # primary
1               # номер раздела
2048            # начальный сектор
+100M           # размер 100MB
n               # новый раздел
p               # primary
2               # номер раздела
[Enter]         # начать сразу после первого раздела
+29.6G          # все оставшееся пространство
w               # записать изменения и выйти
```

Далее нужно отформатировать созданные разделы в файловую систему(vfat) и файловую системы ext4 с соответсвующими метками. Выбор файловых систем обусловлен тем, что u-boot "из коробки" работает с файловой системой vfat, а ext4 просто достаточно надежная и подходит для размещения на нем rootfs.
```
$ sudo mkfs.vfat -n BOOT /dev/sdX1

$ sudo mkfs.ext4 -L ROOTFS /dev/sdX2
```

Готово!

Можно проверить результат

```
$ sudo fdisk -l /dev/sdX
```

## Запись компонентов образа

Сделаю небольшой спойлер и представлю схематично, как будет выглядеть финальное пространство sd-карточки. В нашем случае, она на 32 Гб. 

![alt text](/pictures/разбивка_карты.png)

Теперь нужно пояснить, что и куда будет записано. 

### Запись u-boot

Для начала, запишем u-boot в начало карты командой

```
$ sudo dd if=/путь/до/загрузчика/lichee rv dock/u-boot-sunxi-with-spl.bin of=/dev/sdX bs=1k seek=8
```

Таким образом, загрузчик будет записан до начала таблицы разделов, и первоначальный загрузчик платы сможет передать ему управление. Для этого мы специально пропустили с помощью параметра *seek* 8 килобайт памяти от начала пространства карточки. Синим на картинке изображены пропущенные 8K, а красным пространство занимаемое загрузчиком.

### Раздел BOOT

Теперь, нам необходимо заполнить всем необходимым раздел BOOT

Для начала, положим на BOOT самое главное — ядро(или сжатое ядро .gz) с именем Image(или любым другим). **Перейдем в директорию сборки ИЛИ директорию с готовыми компонентами и выполним** и выполним

Для ядра из *директории Researches_for_Lichee_RV*
```
$ cp kernels/Image_6.16_wifi_rt /путь/до/BOOT/Image
```

Для ядра из *директории с*
```
$ cp kernels/Image /путь/до/BOOT/Image
```

Далее, положим туда же скомпилированный файл device tree из репозитория(по такому же пути можно посмотреть и на исходный dts!).

```
$ cp dts_and_dtb/sun20i-d1-lichee-rv-dock.dtb /путь/до/BOOT/
```

Теперь, нужно создать конфигурационный файл для загрузчика, который сообщит ему, какое ядро запускать, с каким device tree и каким параметрами.

Можно его создать и написать самим, а можно скопировать уже готовую директорию из репозитория, и ознакомиться с содержимым.

```
$ cp -r extlinux /run/media/taranev/BOOT 
```