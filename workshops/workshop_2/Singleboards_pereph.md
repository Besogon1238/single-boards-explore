## Одноплатники и перефирия

В процессе работы с Lichee RV Dock у меня появилась задача сделать возможным работу с SPI-интерфейсом микроконтроллера, что стало неожиданно не самой простой задачей. Затем, появилась аналогичная задача с I2c-интерфейсом. О полученном мною опыте я вам и расскажу.

Нашей целью будет обеспечение работы с простыми переферийными устройствами.

Задачи, которые нам предстоит решить:

- модифицировать изначально данный конфиг ядра Linux 6.16
- дописать необходимые элементы в дереве устройств
- написать простые userspace программы для проверки корректности работы интерфейсов


## Включение платы(напоминалка)

Поскольку нам необходимо работать с платой, а платы у нас достаточно малоресурсные, чтобы работать на графике(хотя с данным образом Lichee RV ее поддерживает) нам нужно работать через консоль. Для работы с консолью пригодиться **UART-преобразователь**, подключаемый на три контакта  GPIO платы. Контакты TX и RX у Lichee RV подписаны на задней стороне платы, а "гребенка" Mango соответствует спецификации "гребенок" Raspberry PI.

![Джампер](/pictures/джампер%20на%20перехооднике.jpg)

Важно правильно выбрать на UART-преобразователе джампером напряжение. В нашем случае, для обоих одноплатников это 3.3V. 

Если выбрать напряжение ниже необходимого — передача данных просто не будет возможной, а вот если выбрать выше, то появится хорошая возможность спалить устройство. **ГОВОРЮ НА СОБСТВЕННОМ ОПЫТЕ, ВНИМАТЕЛЬНЕЕ!**

Подключаем UART-преобразователь к компьютеру. Для удобства может пригодиться usb-удлинитель, если ПК стационарный. Далее, соединяем пин GND на GPIO контактах с пином GND на преобразователе, а RX пины соединяем с TX пинами, и наоборот.

![UART-преобразователь](/pictures/соелинение%20переходника%20с%20GPIO%20ПЛАТЫ.jpg)

Чтобы определить имя устройства в системе можно почитать логи dmesg. Например так:

```
dmesg | grep -i "tty"
```

Подключимся к UART-преобразователю, и ждем поступления сигналов

```
$ tio -b 115200 /dev/ttyUSBX
```

Теперь если вставить флеш-карточку с записанной на нее образом в соответствующий интерфейс на плате, можно увидеть в консоли логи запуска операционной системы, а затем и приглашение ко вводу.

## Краткая теория о самих интерфейсах

### SPI

SPI (Serial Peripheral Interface) — это интерфейс для связи с периферийными устройствами, такими как датчики, преобразователи и память.

![alt text](/pictures/SPImult.png)

Его работа строится по принципу «ведущий-ведомый», где ведущий задаёт такт синхронизации (SCK). По одному проводу (MOSI) данные идут от ведущего к ведомому, а по другому (MISO) — обратно. Это позволяет передавать информацию в обе стороны одновременно. Однако важно помнить, что при каждой записи команды или данных вы всегда получите ответ такой же длины от ведомого устройства, даже если это ответ не несёт полезной информации.

Классическая схема подключения, приведенная на рисунке выше, является параллельной: все ведомые устройства совместно используют линии данных (MOSI, MISO) и тактирования (SCK). Единственным исключением является сигнал выбора ведомого (~CS), который для каждого устройства должен быть индивидуальным. На рисунке эти сигналы обозначены как SSx. Для их формирования можно использовать как специализированные выводы SPI-контроллера, так и универсальные GPIO-пины.

В случае с платой Lichee RV Dock базово предоставляется возможность подключить только одно SPI-устройство, что упрощает схему (см. рисунок ниже).


![alt text](/pictures/SPI.png)

Интерфейс SPI применяется преимущественно во встроенных системах и электронных устройствах для короткой дистанции, обеспечивая высокоскоростной синхронный обмен данными между микроконтроллером (мастером) и периферийными микросхемами (ведомыми). Основные цели его использования — подключение и управление разнообразной периферией, такой как датчики (температуры, давления, акселерометры), карты памяти (SD, MMC), ЦАП/АЦП, сдвиговые регистры, драйверы дисплеев и тд.


### I2C

I2C является шиной, т.е. к одним и тем же выводам может быть подключено несколько устройств. По стандарту на шине есть только одно ведущее устройство - Master, остальные - ведомые, Slave. Ведущее выбирает, с каким из ведомых взаимодействовать, может отправлять и читать с него данные. Ведущим обычно является основной МК в схеме, а остальные - различные цифровые микросхемы, датчики или вспомогательные МК.

![alt text](/pictures/i2c.png)

I2C использует 2 пина для подключения:

- SDA (Serial Data) - линия данных, передача в обе стороны. На модуле может быть подписан как SDA, D
- SCL (Serial Clock) - линия синхронизации, управляет мастер. На модуле может быть подписан как SCL, C, SCK

### Важное уточнение

Сегодня мы не будем детально углубляться в различные сопсобы обмена данными по этим интерфейсам, в структуру пакетов и т.д(хотя для реальной практики это зачастую необходимо). Наша задача сегодня обеспечить саму работу этих интерфейсов и взаимодействие с ними.

## Постановка задачи

Вспомним и сформулируем цель: **обеспечить возможность взаимодействия с интерфейсами микроконтроллера Allwinner D1 из пользовательского пространства операционной системы**.

Сформулировали. Отлично! Но в чем проблема?

А первую проблему можно увидеть, если обратиться к [распиновке](/pictures/pinout.png) или [схеме](/pictures/Scematic.pdf]) изучаемой платы.

Взглянем на распиновку(или на более подробную схему):

![alt text](/pictures/pinout.png)

Можно заметить, что интерфейсы выведены на GPIO-гребенку в качестве дополнительной, а не стандартной функции. Что означает, что по умолчанию ножки процессора, выведенные на указанные пины будут использоваться для работы с RGB-экраном.

Следовательно, первую задачу, которую необходимо решить можно сформулировать так: *"Необходимо сообщить ядру операционной системы об использовании пинов микроконтроллера для работы интерфейсов".* 

Следующая проблема вытекает из первой. Звучит она так: "А какие драйверы ядра могут обеспечить поддержку интерфейса?". И это весьма неочивидная в своей сути проблема, которая будет раскрыта в полной мере позже: в конфигурации ядра и в его исходниках просто не существует отдельного драйвера, обеспечивающего поддержку SPI-интерфейса для семейства микроконтроллеров sun20i(Allwinner D1).

Вторую задачу сформулируем так: "Необходимо добавить в ядро драйверы, которые обеспечат работу интерфейса SPI в пользовательском пространстве". 

## Путь решения

<a name="kernel_compilation"></a>

### Добавление драйвера поддержки интерфейса SPI в ядро 

Начнем со второй, более знакомой нам задачи: сборки ядра. 
Кроме того, сборка ядра на не самом шустром ПК требует времени.

На каждой машине в лаборатории в домашней папке **пользователя demo** расположена директория **/demo**,в которой лежат исходники ядра 6.16. Перейдем в указанный каталог.

В качестве стартовой точки на этом шаге у меня был собственный конфиг для ядра, который был получен привнесением изменений в defconfig для Lichee RV Dock. Кстати найти его можно [здесь](https://github.com/Besogon1238/Researches_for_Lichee_RV/tree/main/configs_for_kernel_6.16/.config_for_6.16_lichee_rt_gpio).

Возьмем исходный конфиг [**ОТСЮДА**] и перенесем его в директорию сборки с именем **.config**.

В нем кстати поддержка самой возможности для ядра работать с SPI интерфейсами уже была включена(параметры SPI и SPI_MASTER). Но этого конечно же недостаточно. Как минимум необходим был драйвер для работы конкретно на нашем SoC, которого... не существует.

"Как же так?" может появится вопрос у прочитавшего предыдущий пункт. Ведь даже в заголовочном файле Device Tree в поле *compatible* у обоих интерфейсов были указаны соответствующие названия драйверов!

Ну...здесь история немного темная, но если разобраться в том, как названия этих драйверов появились там, можно узнать, что конкретным пользователем был предложен патч, добавляющий поддержку SPI для ряда семейств процессоров от компании Allwinner. С описанием внесенных изменений можно ознакомиться [здесь](https://lwn.net/Articles/931179/). 

Исходя из описанного поддержка SPI была осуществлена путем добавления необходимых объектов в device tree и внесением изменений в драйвер spi-sun6i.c, который иначально был предназначен для устройств семейства микроконтроллеров на архитектуре arm. Но ввиду практически идентичной реализации SPI-интерфейса было принято решение добавить в этот же драйвер поддержку еще нескольки семейств, в числе которых было и семейство sun20i.

В сухом остатке оставалось только добавить поддержку этого драйвера в конфиг ядра(SPI_SUN6I).

Произведем донастройку получившейся конфигурации.

```
$ make ARCH=riscv menuconfig
```

P.S указание архитектуры здесь необходимо для того, чтобы система сборки обратилась к директории arch/riscv/ для получения всех архитектурно-зависимых настроек, списков плат и драйверов.

 Жмем (/) и пишем названия параметра в появившееся поле ввода.

![alt text](/pictures/search_in_menuconfig.png)

### Добавление сопутствующих драйверов

В процессе попыток заставить драйвер *SPI_SUN6I* работать выяснилось, что инициализировать устройство у драйвера не получается, поскольку у него не получается получить доступ к DMA каналам. В ходе мыслительной деятельности появилась идея о том, что драйверу SPI для другого семейства микроконтроллеров может не хватать драйвера DMA для этого же семейства. Иии...да! Ровно так и оказалось! Добавление драйвера *DMA_SUN6I* наконец таки позволило добиться желаемого результата.

По завершении указанных действий, можно произвести попытку запуска сборки командой.

```
$ make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- -j$(nproc)
```

После окончания сборки по пути *arch/riscv/boot/* можно будет найти бинарный файл готового ядра, а также его сжатый вариант с расширеним .gz.

### Добавление и активация интерфейса в Device Tree

Для начала стоит коротко пояснить, как при сборке ядра формируются бинарные .dtb файлы из исходников дерева устройств. Все довольно просто, рассмотрим на примере lichee_rv_dock.

В папке исходников ядра по пути *arch/riscv/boot/dts/allwinner/* лежат исходники дерева устройств для одноплатников на чипе Allwinner D1.

Если открыть файл [*sun20i-d1-lichee-rv-dock.dts*](https://github.com/Besogon1238/Researches_for_Lichee_RV/blob/main/dts_and_dtb/sun20i-d1-lichee-rv-dock.dts), то можно заметить в самом начале включение в него аналогичного файла [*sun20i-d1-lichee-rv.dts*](https://github.com/Besogon1238/Researches_for_Lichee_RV/blob/main/dts_and_dtb/sun20i-d1-lichee-rv.dts)для более "голой" версии одноплатника. В свою очередь, в этом файле можно тоже обнаружить включение файлов с более общими параметрами. Пройдя весь цикл таких вложенностей можно наконец добраться до файла [*sunxi-d1s-t113.dtsi*](https://github.com/Besogon1238/Researches_for_Lichee_RV/blob/main/dts_and_dtb/sunxi-d1s-t113.dtsi),в котором и содержится объявление всех возможных интерфейсов и устройств, которые могут поддерживаться устройствами на базе микроконтроллера D1. По сути говоря такие файлы формата .dtsi являются заголовочными файлами для исходных файлов формата .dts. Буква *i* в названии и означает слово *include*.

Найдем объявления связанные с SPI в заголовочном файле.

**Объявление пинов микроконтроллера**, которые поддерживают работу двух SPI интерфейсов(spi0 и spi1). Убедится в полном соответствии исходников реальности можно, взглянув на более подробную [схему одноплатника]((/pictures/Scematic.pdf])).

```
/omit-if-no-ref/
spi0_pins: spi0-pins {
        pins = "PC2", "PC3", "PC4", "PC5";
        function = "spi0";
};

/omit-if-no-ref/
spi1_pb_pins: spi1-pb-pins {
        pins = "PB0", "PB8", "PB9", "PB10", "PB11", "PB12";
        function = "spi1";
};

/omit-if-no-ref/
spi1_pd_pins: spi1-pd-pins {
        pins = "PD10", "PD11", "PD12", "PD13", "PD14", "PD15";
        function = "spi1";
};
```

P.S директива */omit-if-no-ref/* в данном случае необходима для невключения в готовый .dtb файл тех объектов, которые ни разу после объявления нигде не упоминаются.

**Объявление SPI интерфейсов**,в которых указано с какими аппаратными прерываниями, интерфейсами и железом должен пользоваться интерфейс:

```
spi0: spi@4025000 {
        compatible = "allwinner,sun20i-d1-spi",
                        "allwinner,sun50i-r329-spi";
        reg = <0x4025000 0x1000>;
        interrupts = <31 IRQ_TYPE_LEVEL_HIGH>;
        clocks = <&ccu CLK_BUS_SPI0>, <&ccu CLK_SPI0>;
        clock-names = "ahb", "mod";
        resets = <&ccu RST_BUS_SPI0>;
        dmas = <&dma 22>, <&dma 22>;
        dma-names = "rx", "tx";
        num-cs = <1>;
        status = "disabled";
        #address-cells = <1>;
        #size-cells = <0>;
};

spi1: spi@4026000 {
        compatible = "allwinner,sun20i-d1-spi-dbi",
                        "allwinner,sun50i-r329-spi-dbi",
                        "allwinner,sun50i-r329-spi";
        reg = <0x4026000 0x1000>;
        interrupts = <32 IRQ_TYPE_LEVEL_HIGH>;
        clocks = <&ccu CLK_BUS_SPI1>, <&ccu CLK_SPI1>;
        clock-names = "ahb", "mod";
        resets = <&ccu RST_BUS_SPI1>;
        dmas = <&dma 23>, <&dma 23>;
        dma-names = "rx", "tx";
        num-cs = <1>;
        status = "disabled";
        #address-cells = <1>;
        #size-cells = <0>;
};
```

Интересным для нас полем впоследствии станет параметр **compatible**, в котором указываются названия драйверов,которые поддерживают работу с тем или иным устройством. При чем, первым в последовательности указывается тот драйвер, которым устройство и нужно инициализировать в первую очередь.

При загрузке ядра драйвера вычитывают из этого поля у активных устройств строку и при обнаружении поддерживаемого устройства вызывают функцию probe для инициализации устройства в ОС.

Можно заметить, что статус обоих устройств говорит о том, что устройство отключено. Этот факт нам предстоит исправить в [исходном файле](https://github.com/Besogon1238/Researches_for_Lichee_RV/blob/main/dts_and_dtb/sun20i-d1-lichee-rv-dock.dts) платы. На текущем этапе в нем нет ничего связанного с SPI.

Итак, добавим в конец файла следующее:

```
&spi1 {
        pinctrl-0 = <&spi1_pd_pins>;
        pinctrl-names = "default";
        status = "okay";
};
```

Данной записью мы определеям или переопределяем описанные параметры. В первую очередь, мы объявляем интерфейс включенным и указываем, на каких именно пинах будет идти обмен.

На самом деле, это не последнее внесенное в исходный файл дерева устройств изменение. Здесь нужно забежать несколько вперед и упомянуть, что все изначально было сделано ради получения возможности из пользовательского пространства работать с SPI интерфейсом. Такой функционал в Linux обеспечивает отдельный драйвер  **SPIDEV**.
Его поддержку необходимо будет добавить в конфиг сборки ядра(параметр SPI_SPIDEV). Кроме того, исходя из [наиболее актуальной документации](https://www.kernel.org/doc/html/latest/spi/spidev.html) к драйверу для того, чтобы устройство было подхвачено драйвером необходимо чтобы оно присутствовало в одной из трех таблиц устройств, жестко заданных внутри исходного кода драйвера. Наше устройство естественно в такой таблице не присуствует. 

В зависимости от ваших предпочтений можно поступить двумя способами: либо добавить свое устройство в одну из этих таблиц и скомпилировать измененный драйвер для ядра, либо в поле .compatible, указываемое при объявлении символьного устройства в Device Tree указать то устройство, которое в этих таблицах уже есть.

Я выбрал второй способ:

```
&spi1{
        pinctrl-0 = <&spi1_pd_pins>;
        pinctrl-names = "default";
        status = "okay";
        spidev0: spidev@0 {
            compatible = "rohm,dh2228fv";
            spi-max-frequency = <100000000>;
            reg = <0x00>;
    };
```

На этом преобразовании Device Tree окончено.

### Добавление и активация интерфейса I2C в ядре и Device Tree

По аналаогичному сценарию развивается и добавление в дерево устройства устройства I2C. 

В исходный файл добавляем:

```
&i2c2 {
        pinctrl-0 = <&i2c2_pepg_pins>;
        pinctrl-names = "default";
        #compatible = "marvell,mv64xxx-i2c";
        status = "okay";
        ssd1306: ssd1306@3c {
                compatible = "solomon,ssd1306";
                reg = <0x3c>;
                solomon,height = <128>;
                solomon,width = <64>;
                solomon,page-offset = <0>;
        };
};
```

В заголовочный файл *sun20i-d1.dtsi* добавляем:

```
/omit-if-no-ref/
i2c2_pepg_pins: i2c2-pepg-pins {
        pins = "PE12", "PG15";
        function = "i2c2";
};
```

В ядро же необходимо добавить следующие драйвера:

I2C_CHARDEV, I2C_MUX.


## Финал

### Проверка работы SPI

В качестве результата можно порадоваться, обнаружить в каталоге /dev/ символьное spidev устройство и протестировать работу интерфейса самым тривиальным способом, замкнув MOSI и MISO пины друг на друга, а затем запустить простой тест на питоне.

```
#!/usr/bin/env python3

import spidev
import time

def spi_sequential_test(bus=0, device=0, speed=1000000):
    try:
        spi = spidev.SpiDev()
        spi.open(bus, device)
        spi.max_speed_hz = speed
        spi.mode = 0
        spi.lsbfirst = False


        print("SPI последовательный тест запущен...")
        print("Отправляю данные: 0, 1, 2, 3, ...")
        print("-" * 40)

        for i in range(256):  # От 0 до 255
            # Отправляем одно число и получаем ответ
            data_to_send = [i]
            response = spi.xfer2(data_to_send)

            print(f"Отправлено: {data_to_send[0]:3d} (0x{data_to_send[0]:02X}) | "
                  f"Получено: {response[0]:3d} (0x{response[0]:02X}) | "
                  f"Бинарно: {response[0]:08b}")

            time.sleep(0.01)

        spi.close()

    except Exception as e:

# Запуск теста
if __name__ == "__main__":
    # Настройте под вашу плату
    spi_sequential_test(bus=0, device=0, speed=1000000)

```

По недосмотру организатора воркшопа для запуска программы будет не хватать пакетов.

Для этого выполняем слудующее:

```
# Подключаемся к интернету с помощью nmcli dev wifi

# mkdir /var/cache/apt/archives/partial

# apt-get update

# apt-get install python3 python3-module-spidev 

# apt-get isntall python3-module-luma-oled #для I2C

```

### Проверка работы I2C

Предлагаю для корректности работы любой понравившийся вам скрипт на С/python/bash [отсюда](https://github.com/Besogon1238/single-boards-explore/tree/main/code_for_riscv). Какие то точно работают))